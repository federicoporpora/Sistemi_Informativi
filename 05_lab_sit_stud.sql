/*
ES 1
date le relazioni
R_LAB5(A,C*) in cui C è una chiave che ammette valori nulli,
S_LAB5(B,C) in cui C referenzia R_LAB5.C
*/
DROP TABLE R_LAB5;
DROP TABLE S_LAB5;

CREATE TABLE R_LAB5(
A VARCHAR(10) NOT NULL PRIMARY KEY,
C VARCHAR(10)
);
CREATE TABLE S_LAB5(
B VARCHAR(10) NOT NULL PRIMARY KEY,
C VARCHAR(10) NOT NULL
);

--si definiscano gli opportuni trigger per:
--1. Garantire l’unicità dei valori di R_LAB5.C
CREATE OR REPLACE TRIGGER CheckRCUnique
BEFORE INSERT ON R_LAB5
REFERENCING NEW AS N
FOR EACH ROW
WHEN (EXISTS (SELECT *
			  FROM R_LAB5
			  WHERE R_LAB5.C = N.C))
SIGNAL SQLSTATE '70000' ('Il parametro C era già presente nella tabella')

--TEST
INSERT INTO R_LAB5 VALUES ('FEDERICO', 'PORPORA');
INSERT INTO R_LAB5 VALUES ('TOMMASO', 'PORTOLANI');
INSERT INTO R_LAB5 VALUES ('MATTEO', 'GATTOBIGIO');
INSERT INTO R_LAB5 VALUES ('ANDREA', 'PORPORA'); --deve dare errore

--2. Imporre il vincolo di integrità referenziale su S_LAB5.C
CREATE OR REPLACE TRIGGER ReferencesSC
BEFORE INSERT ON S_LAB5
REFERENCING NEW AS N
FOR EACH ROW
WHEN (NOT EXISTS (SELECT *
				  FROM R_LAB5
				  WHERE R_LAB5.C = N.C))
SIGNAL SQLSTATE '70001' ('Il dato inserito in S_LAB5 non ha il corrispettivo R_LAB5.C')

--TEST
INSERT INTO S_LAB5 VALUES ('FEDERICO', 'PORPORA');
INSERT INTO S_LAB5 VALUES ('TOMMASO', 'GUERRA');--deve dare errore

--3. Gestire una politica di cancellazione in cascata su S_LAB5 quando vengono
--cancellate tuple di R_LAB5
CREATE OR REPLACE TRIGGER OnDeleteCascadeS
AFTER DELETE ON R_LAB5
REFERENCING OLD AS O
FOR EACH ROW
DELETE FROM S_LAB5
WHERE O.C = S_LAB5.C

--TEST
DELETE FROM R_LAB5 WHERE R_LAB5.A = 'FEDERICO' AND R_LAB5.C = 'PORPORA';--deve cancellare il dato anche in S_LAB5




--ES 2
DROP TABLE PRODOTTI_LAB5;
DROP TABLE ORDINI_LAB5;
DROP TABLE VENDITE_LAB5;

CREATE TABLE PRODOTTI_LAB5(
    PCODE 	 CHAR(5) NOT NULL PRIMARY KEY,  	
    DESCRIZIONE VARCHAR(20) NOT NULL,
	PREZZO 	 DEC(6,2) NOT NULL CHECK (PREZZO > 0));
CREATE TABLE ORDINI_LAB5(
	ID 		 CHAR(5) NOT NULL PRIMARY KEY,
	NOMECLIENTE VARCHAR(20) NOT NULL,
	SPESESPEDIZIONE DEC(6,2) NOT NULL DEFAULT 7 CHECK (SPESESPEDIZIONE = 7), 
	TOTALE 	 DEC(6,2) NOT NULL CHECK (TOTALE >=0));
CREATE TABLE VENDITE_LAB5(
	PCODE 	 CHAR(5) NOT NULL REFERENCES PRODOTTI_LAB5,
	ID 		 CHAR(5) NOT NULL REFERENCES ORDINI_LAB5,
	QUANTITA INT NOT NULL CHECK (QUANTITA > 0),
	PRIMARY KEY (PCODE,ID));

--si definiscano i trigger per mantenere ORDINI_LAB5.Totale aggiornato:
--1. quando si inseriscono nuovi prodotti nell’ordine
CREATE OR REPLACE TRIGGER AddSpeseSpedizione
AFTER INSERT ON ORDINI_LAB5
REFERENCING NEW AS N
FOR EACH ROW
UPDATE ORDINI_LAB5
SET ORDINI_LAB5.TOTALE = N.TOTALE + N.SPESESPEDIZIONE
WHERE N.ID = ORDINI_LAB5.ID

CREATE OR REPLACE TRIGGER UpdateTotaleOnInsert
AFTER INSERT ON VENDITE_LAB5
REFERENCING NEW AS N
FOR EACH ROW
UPDATE ORDINI_LAB5
SET ORDINI_LAB5.TOTALE = ORDINI_LAB5.TOTALE + N.QUANTITA * (SELECT p.PREZZO
												   FROM PRODOTTI_LAB5 p
												   WHERE N.PCODE = p.PCODE)
WHERE ORDINI_LAB5.ID = N.ID

--TEST
INSERT INTO PRODOTTI_LAB5 VALUES ('33B', 'Burro', 3.99);
INSERT INTO ORDINI_LAB5 VALUES ('1', 'FedericoPorpora', DEFAULT, 0.0);
INSERT INTO ORDINI_LAB5 VALUES ('2', 'TommasoPortolani', DEFAULT, 0.0);
INSERT INTO VENDITE_LAB5 VALUES ('33B', '1', 2);
INSERT INTO VENDITE_LAB5 VALUES ('33B', '2', 1);


--2. quando si modifica (in più o in meno) la quantità di un prodotto (che
--deve essere comunque sempre maggiore di zero)
CREATE OR REPLACE TRIGGER UpdateTotaleOnQuantityUpdate
AFTER UPDATE OF QUANTITA ON VENDITE_LAB5
REFERENCING NEW AS N OLD AS O
FOR EACH ROW
UPDATE ORDINI_LAB5
SET ORDINI_LAB5.TOTALE = ORDINI_LAB5.TOTALE + (N.QUANTITA - O.QUANTITA) * (SELECT p.PREZZO
																 FROM PRODOTTI_LAB5 p
																 WHERE p.PCODE = N.PCODE)
WHERE ORDINI_LAB5.ID = N.ID

--TEST
UPDATE VENDITE_LAB5 SET QUANTITA = 4 WHERE ID = '2';


--3. quando si eliminano prodotti dall’ordine
CREATE OR REPLACE TRIGGER UpdateTotaleOnSalesDelete
AFTER DELETE ON VENDITE_LAB5
REFERENCING OLD AS O
FOR EACH ROW
UPDATE ORDINI_LAB5
SET ORDINI_LAB5.TOTALE = ORDINI_LAB5.TOTALE - O.QUANTITA * (SELECT p.PREZZO
												  FROM PRODOTTI_LAB5 p
												  WHERE p.PCODE = O.PCODE)
WHERE ORDINI_LAB5.ID = O.ID

--TEST
DELETE FROM VENDITE_LAB5 WHERE ID = '2'




--ES 3
DROP TABLE STUDENTI_LAB5;
DROP TABLE CORSI_LAB5;
DROP TABLE APPELLI_LAB5;
DROP TABLE ESAMI_LAB5;
DROP TABLE VERBALIZZAZIONI_LAB5;

CREATE TABLE STUDENTI_LAB5(
	MATR CHAR(6) NOT NULL PRIMARY KEY,  -- CHAR(6) solo per brevita'
	NOME VARCHAR(30) NOT NULL,
	COGNOME VARCHAR(30) NOT NULL);
CREATE TABLE CORSI_LAB5 (
    CODC CHAR(3) NOT NULL PRIMARY KEY,
	NOME VARCHAR(30) NOT NULL);
CREATE TABLE APPELLI_LAB5 (
    CODC CHAR(3) NOT NULL REFERENCES CORSI_LAB5,
	DATA DATE NOT NULL, 
	LUOGO VARCHAR(30) NOT NULL,
	PRIMARY KEY (CODC, DATA));
CREATE TABLE ESAMI_LAB5 (
	MATR CHAR(6) NOT NULL REFERENCES STUDENTI_LAB5,
    CODC CHAR(3) NOT NULL,
	DATA DATE NOT NULL, 
	VOTO INT NOT NULL CHECK (VOTO BETWEEN 0 AND 31),
	ACCETTATO CHAR(1) DEFAULT NULL CHECK (ACCETTATO = 'Y'),
	FOREIGN KEY (CODC, DATA) REFERENCES APPELLI_LAB5,
	PRIMARY KEY (MATR, CODC, DATA));
CREATE TABLE VERBALIZZAZIONI_LAB5 (
	MATR CHAR(6) NOT NULL REFERENCES STUDENTI_LAB5,
  	CODC CHAR(3) NOT NULL,
	DATA DATE NOT NULL, 
	VOTO INT NOT NULL CHECK (VOTO BETWEEN 18 AND 31),
	FOREIGN KEY (CODC, DATA) REFERENCES APPELLI_LAB5,
	PRIMARY KEY (MATR, CODC));

-- Inserimenti validi 
INSERT INTO STUDENTI_LAB5 VALUES ('765432', 'Alan', 'Turing');
INSERT INTO CORSI_LAB5 VALUES ('SIT', 'Sistemi Informativi T'), 
						 ('CET', 'Calcolatori Elettronici T');
INSERT INTO APPELLI_LAB5 VALUES ('SIT', '10.02.2024', 'LAB 4'),
						   ('SIT', '22.06.2024', 'LAB 9'),
						   ('CET', '20.01.2024', 'AULA 2.9'),
						   ('CET', '14.07.2024', 'AULA 2.4');
INSERT INTO ESAMI_LAB5 VALUES ('765432', 'SIT', '10.02.2024', 19, NULL),
						 ('765432', 'SIT', '22.06.2024', 30, NULL),
			 			 ('765432', 'CET', '20.01.2024', 15, NULL),
			 			 ('765432', 'CET', '14.07.2024', 31, NULL);

--Si definiscano gli opportuni trigger, sapendo che:
--1. Quando si accetta un Voto (Accettato si aggiorna dal valore di default NULL a 'Y'),
--si inseriscono con un trigger in VERBALIZZAZIONI_LAB5 i dati corrispondenti all'esame scelto
CREATE OR REPLACE TRIGGER UpdateVerbalizzazioniOnAccettazione
AFTER UPDATE OF ACCETTATO ON ESAMI_LAB5
REFERENCING NEW AS N
FOR EACH ROW
INSERT INTO VERBALIZZAZIONI_LAB5 VALUES (N.MATR, N.CODC, N.DATA, N.VOTO)

--TEST
UPDATE ESAMI_LAB5 SET ACCETTATO = 'Y' WHERE MATR = '765432' AND CODC = 'SIT' AND DATA = '22.06.2024' AND VOTO = 30


--2. Dopo la verbalizzazione di un voto tutti gli esami relativi alla relativa coppia (studente, corso)
--vanno cancellati da ESAMI_LAB5 mediante un trigger
CREATE OR REPLACE TRIGGER DeleteExamAfterVerbalization
AFTER INSERT ON VERBALIZZAZIONI_LAB5
REFERENCING NEW AS N
FOR EACH ROW
DELETE FROM ESAMI_LAB5
WHERE ESAMI_LAB5.MATR = N.MATR AND ESAMI_LAB5.CODC = N.CODC

--TEST
UPDATE ESAMI_LAB5 SET ACCETTATO = 'Y' WHERE MATR = '765432' AND CODC = 'SIT' AND DATA = '22.06.2024' AND VOTO = 30


--3. Non deve essere possibile, per uno stesso studente, accettare 2 o più voti di più esami di uno
--stesso corso (al max una 'Y' per una coppia (studente, corso) )
CREATE OR REPLACE TRIGGER ErrorOnDoubleVerbalization
BEFORE UPDATE OF ACCETTATO ON ESAMI_LAB5
REFERENCING NEW AS N
FOR EACH ROW
WHEN (EXISTS (SELECT *
			  FROM VERBALIZZAZIONI_LAB5 v
			  WHERE v.MATR = N.MATR AND v.CODC = N.CODC))
SIGNAL SQLSTATE '70002' ('È già stato verbalizzato un voto dello stesso corso, non è possibile verbalizzarne un altro')

--TEST
INSERT INTO ESAMI_LAB5 VALUES ('765432', 'SIT', '10.02.2024', 19, NULL);
UPDATE ESAMI_LAB5 SET ACCETTATO = 'Y' WHERE MATR = '765432' AND CODC = 'SIT' AND DATA = '10.02.2024' AND VOTO = 19;

--4. Non deve essere possibile inserire direttamente in ESAMI_LAB5 il valore Accettato = 'Y' 
CREATE OR REPLACE TRIGGER ErrorOnExamInsertWithY
AFTER INSERT ON ESAMI_LAB5
REFERENCING NEW AS N
FOR EACH ROW
WHEN (N.ACCETTATO = 'Y')
SIGNAL SQLSTATE '70003' ('Non è possibile aggiungere un esame con Y come verbalizzazione')

--TEST
INSERT INTO APPELLI_LAB5 VALUES ('SIT', '28.02.2024', 'LAB 4');
INSERT INTO ESAMI_LAB5 VALUES ('765432', 'SIT', '28.02.2024', 15, 'Y');